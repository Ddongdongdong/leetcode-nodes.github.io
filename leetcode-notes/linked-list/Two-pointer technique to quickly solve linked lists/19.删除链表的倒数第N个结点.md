单链表无法随机访问，也无法从尾部逆序遍历。若先遍历求长度 k，再定位到第 k-n+1 个节点，需要两次遍历。


解法思路
fast 指针先走 n（或 n+1）步，使得 fast 和 slow 之间保持固定间距；随后 fast、slow 同步前进；当 fast 到达链表末尾时，slow 恰好位于目标位置。为处理“删除头节点”这种边界情况，引入 哑节点 dummy，把删除逻辑统一为“删除某节点的前驱节点的 Next”。
创建哑节点 dummy，令 dummy.Next = head。让 fast 从 dummy 出发先走 n+1 步（保持与 slow 间距为 n+1）。让 slow 从 dummy 出发，与 fast 同步前进直到 fast == nil。此时 slow 指向 待删除节点的前一个节点，执行：slow.Next = slow.Next.Next返回 dummy.Next 作为新的头结点。

解法代码：
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val  int
 *     Next *ListNode
 * }
 */

func findCountdownPrev(head *ListNode, step int) *ListNode {
    fast := head
    // fast 先走 step 步，使 slow 与 fast 保持固定间距
    for i := 0; i < step; i++ {
        fast = fast.Next
    }

    slow := head
    // fast 走到 nil 时，slow 位于目标位置（这里设计为“待删除节点的前驱”）
    for fast != nil {
        fast = fast.Next
        slow = slow.Next
    }
    return slow
}

func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummy := &ListNode{Val: -1, Next: head}

    // 找到待删除节点的前驱：倒数第 n 个节点的前一个节点
    prev := findCountdownPrev(dummy, n+1)

    // 删除倒数第 n 个节点
    prev.Next = prev.Next.Next

    return dummy.Next
}
时间复杂度：O(n)
空间复杂度：O(1)




