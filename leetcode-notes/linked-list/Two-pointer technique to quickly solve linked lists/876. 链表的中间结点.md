在面对单链表的中间/倒数第K个/是否有环/环入口/相交点这样的类似的问题的时候，优先想到用快慢指针（Two Pointers）：因为链表不能像数组一样随机访问第n/2个元素，但是要是先遍历一遍链表算长度再走一半的时候，这种情况就会出现两次遍历的情况，很容易出现边界bug，在链表的长度为偶数的时候，左右中点的问题的时候很容易出现bug。
解法代码：
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func middleNode(head *ListNode) *ListNode {
    slow, fast := head, head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }
    return slow
}
时间复杂度：O(n)
空间复杂度：O(1)
这样设计快慢指针的目的就是让fast经历的步数是slow经历的步数的2倍，当fast到链表结尾的时候，slow走到中间节点。
衍生出解决类似问题的一个通用模板：
模板 A：找中点（偏右）
slow, fast := head, head
for fast != nil && fast.Next != nil {
    slow = slow.Next
    fast = fast.Next.Next
}
return slow
时间复杂度：O(n)
空间复杂度：O(1)
模板 B：找中点（偏左）
slow, fast := head, head
for fast.Next != nil && fast.Next.Next != nil {
    slow = slow.Next
    fast = fast.Next.Next
}
return slow
时间复杂度：O(n)
空间复杂度：O(1)
模板 C：判断单链表中是否有环
slow, fast := head, head
for fast != nil && fast.Next != nil {
    slow = slow.Next
    fast = fast.Next.Next
    if slow == fast {
        return true
    }
}
return false
时间复杂度：O(n)
空间复杂度：O(1)

