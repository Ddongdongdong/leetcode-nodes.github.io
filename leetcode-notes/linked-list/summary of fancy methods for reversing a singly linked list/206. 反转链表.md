2025-12-22
单链表的反转（Reverse Linked List）
一、问题背景

单链表的一个重要特性：

只能从前往后遍历

不能直接从后往前遍历

因此，当想要“反转链表”时，不能简单地从尾部向前走，而必须通过改变指针关系或借助外部结构来实现。

二、反转单链表的三种常见方法
方法一：原地修改指针

核心思想是：

在遍历链表的过程中，把当前节点的 next 指针反向指向前一个节点，并在移动指针前，提前保存好“后面的链表”，防止断链。


cur：当前正在处理的节点

prev：已经反转完成的链表头

next_temp：临时保存 cur 的下一个节点（防止断链）

代码实现
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev = None
        cur = head

        while cur:
            next_temp = cur.next  
            cur.next = prev       
            prev = cur            
            cur = next_temp     

        return prev

时间复杂度：O(n)

空间复杂度：O(1)
不借助额外数据结构效率最高



方法二：借助外部数据结构（栈 / 数组）
思路说明

既然单链表无法从后向前遍历，我们可以借助 栈或数组的“后进先出 / 随机访问”特性，先把链表节点保存起来，再按相反顺序重新连接。不是链表在反转，而是借助外部结构绕过限制

实现步骤

遍历链表，将所有节点压入栈

从栈中依次弹出节点，重新连接 next

最后将尾节点的 next 置为 None

代码实现（修正版）
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head:
            return None

        stack = []
        cur = head

        # 1. 入栈
        while cur:
            stack.append(cur)
            cur = cur.next

        # 2. 出栈重连
        new_head = stack.pop()
        cur = new_head

        while stack:
            node = stack.pop()
            cur.next = node
            cur = node

        cur.next = None
        return new_head

时间复杂度：O(n)空间复杂度：O(n)

思路直观，实现简单，但空间复杂度较高，面试不推荐作为首选

方法三：递归（本质也是栈）

递归的核心思想是：先递归到链表尾部，再在回溯阶段一层一层反转指针

代码实现
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head

        new_head = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return new_head

复杂度分析

时间复杂度：O(n)

空间复杂度：O(n)