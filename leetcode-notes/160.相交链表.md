给定两个单链表的头节点 headA 和 headB ，请找出并返回两个单链表相交的起始节点。如果两个链表不存在合并节点，返回 nil 。
常规解法：
  统计长度： 分别遍历链表 A 和 B，得到它们的长度 lenA 和 lenB。计算差值： 计算长度差 diff = abs(lenA - lenB)。对齐起点：将指向较长链表的指针向后移动 diff 步。此时，两个指针距离链表末尾的距离相等。同步移动： 同时移动两个指针，每次各走一步，并比较两个指针指向的地址。查找结果： * 如果指针相等，则该节点即为相交节点。如果直到链表末尾（均为 nil）仍不相等，则说明不相交。
代码实现：
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    lena,lenb:=0,0
    for i:=headA;i!=nil;i=i.Next{
        lena++
    }
    for i:=headB;i!=nil;i=i.Next{
        lenb++
    }
    pointa,pointb:=headA,headB
    if lena>lenb{
        for i:=0;i<lena-lenb;i++{
            pointa=pointa.Next
        }
    }else{
        for i:=0;i<lenb-lena;i++{
            pointb=pointb.Next}    
        }
    for pointa!=pointb{
       pointa=pointa.Next
       pointb=pointb.Next
    }
    return pointa

}
时间复杂度: O(m + n)
空间复杂度: O(1)
双指针：
这种方法看起来更简单，要充分理解一下，用两个指针从不同的头节点出发，将两个链表拼接在一起，两个指针走过的总路程是相等的。
具体步骤拆解：
可以把整个过程想象成两个人在两条长度不一的环形跑道上跑步：第一轮遍历：pA 走完 A，pB 走完 B。如果 A和 B长度不等，它们到达末尾的时间不同。交换起点：pA 走到 nil 时，重置到 headB。pB 走到 nil 时，重置到 headA。第二轮相遇：由于交换了起点，这就消除了长度差。如果两链表相交，它们会在交点处相等（pA == pB）。如果两链表不相交，它们会同时走到末尾的 nil（此时也满足 pA == pB，都等于 nil），循环结束。

代码实现：

func getIntersectionNode(headA, headB *ListNode) *ListNode {
    if headA == nil || headB == nil {
        return nil
    }

    pA, pB := headA, headB

    for pA != pB {
       
        if pA == nil {
            pA = headB
        } else {
            pA = pA.Next
        }


        if pB == nil {
            pB = headA
        } else {
            pB = pB.Next
        }
    }

    return pA
}
时间复杂度：O(m+n)
空间复杂度：O(1)
